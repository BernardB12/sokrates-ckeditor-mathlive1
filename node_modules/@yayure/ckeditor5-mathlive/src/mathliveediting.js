import MathliveCommand from './mathlivecommand';
import { Plugin } from 'ckeditor5/src/core';
import { toWidget, Widget, viewToModelPositionOutsideModelElement } from 'ckeditor5/src/widget';
import { CKEditorError } from 'ckeditor5/src/utils';
export default class MathliveEditing extends Plugin {
    static get requires() {
        return [Widget];
    }
    static get pluginName() {
        return 'MathliveEditing';
    }
    constructor(editor) {
        super(editor);
        const mathliveConfig = editor.config.get('mathlive');
        editor.config.define('mathlive', {
            mathPanelDestroyOnClose: false,
            openPanelWhenEquationSelected: false,
            processClass: 'tex2jax_process',
            processScriptType: 'math/tex',
            output: {
                type: 'script',
                attributes: mathliveConfig?.output?.attributes ? mathliveConfig.output.attributes : {
                    type: 'math/tex'
                }
            }
        });
    }
    init() {
        const editor = this.editor;
        editor.commands.add('mathlive', new MathliveCommand(editor));
        this._defineSchema();
        this._defineConverters();
        editor.editing.mapper.on('viewToModelPosition', viewToModelPositionOutsideModelElement(editor.model, viewElement => viewElement.hasClass('math')));
    }
    _defineSchema() {
        const schema = this.editor.model.schema;
        schema.register('mathlive-mathtex', {
            allowWhere: '$text',
            isInline: true,
            isObject: true,
            allowAttributes: ['equation', 'alignment', 'fontSize', 'fontColor', 'fontBackgroundColor',
                'bold', 'linkHref', 'code']
        });
    }
    _defineConverters() {
        const conversion = this.editor.conversion;
        const mathliveConfig = this.editor.config.get('mathlive');
        // View -> Model
        conversion
            .for('upcast')
            // (e.g. <span class="tex2jax_process">\sqrt{\frac{a}{b}}</span>)
            .elementToElement({
            view: {
                classes: [mathliveConfig.processClass]
            },
            model: createMathtexModel
        })
            // (e.g. <script type="math/tex">\sqrt{\frac{a}{b}}</script>)
            .elementToElement({
            view: {
                name: 'script',
                attributes: {
                    type: 'math/tex'
                }
            },
            model: createMathtexModel
        })
            .elementToElement({
            view: {
                name: mathliveConfig.output.type,
                attributes: mathliveConfig.output.attributes
            },
            model: createMathtexModel
        });
        // Create view for Model
        function createMathtexModel(viewElement, { writer }) {
            const child = viewElement.getChild(0);
            if (child?.is('$text')) {
                const equation = child.data.trim();
                return writer.createElement('mathlive-mathtex', {
                    equation
                });
            }
            return null;
        }
        // Model -> View (element)
        conversion
            .for('editingDowncast')
            .elementToElement({
            model: 'mathlive-mathtex',
            view: (modelItem, { writer }) => {
                const widgetElement = createMathtexEditingView(modelItem, writer);
                return toWidget(widgetElement, writer);
            }
        });
        // Model -> Data
        conversion
            .for('dataDowncast')
            .elementToElement({
            model: 'mathlive-mathtex',
            view: createMathtexView
        });
        // Create view for editor
        function createMathtexEditingView(modelItem, writer) {
            const equation = String(modelItem.getAttribute('equation'));
            const mathtexView = writer.createContainerElement('span', {
                style: 'display: inline-block;',
                class: 'ck-mathlive-tex'
            });
            const mathFieldWrapper = writer.createContainerElement('span', {
                class: 'ck-math-field'
            });
            const mathField = writer.createContainerElement('math-field', {
                'read-only': ''
            });
            writer.insert(writer.createPositionAt(mathField, 0), writer.createText(equation));
            writer.insert(writer.createPositionAt(mathFieldWrapper, 0), mathField);
            writer.insert(writer.createPositionAt(mathtexView, 0), mathFieldWrapper);
            return mathtexView;
        }
        // Create view for data
        function createMathtexView(modelItem, { writer }) {
            const equation = modelItem.getAttribute('equation');
            if (typeof equation != 'string') {
                /**
                * Couldn't find equation on current element
                * @error missing-equation
                */
                // eslint-disable-next-line ckeditor5-rules/ckeditor-error-message
                throw new CKEditorError('missing-equation', { pluginName: 'mathlive' });
            }
            const { output } = mathliveConfig;
            if (output) {
                const mathtexView = writer.createContainerElement(output.type, output.attributes);
                writer.insert(writer.createPositionAt(mathtexView, 0), writer.createText(equation));
                return mathtexView;
            }
        }
    }
}
